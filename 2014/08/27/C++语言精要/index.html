<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuzihaofzh.github.io","root":"/blog/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="By Z.H. Fu https:&#x2F;&#x2F;fuzihaofzh.github.io&#x2F;blog&#x2F; ### 几种必考虑的情况 - 只要有除法，就一定要讨论分母为0； - 一定要判断函数输入参数是否合法； - 指针使用时判断是否非0，用完了置为0。  函数压栈顺序 从右往左。 所以 int g &#x3D; 1; printf(&quot;%d, %d&quot;, g, ++g);  结果为2,2 int g &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++语言精要">
<meta property="og:url" content="http://fuzihaofzh.github.io/blog/2014/08/27/C++%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81/index.html">
<meta property="og:site_name" content="切问录">
<meta property="og:description" content="By Z.H. Fu https:&#x2F;&#x2F;fuzihaofzh.github.io&#x2F;blog&#x2F; ### 几种必考虑的情况 - 只要有除法，就一定要讨论分母为0； - 一定要判断函数输入参数是否合法； - 指针使用时判断是否非0，用完了置为0。  函数压栈顺序 从右往左。 所以 int g &#x3D; 1; printf(&quot;%d, %d&quot;, g, ++g);  结果为2,2 int g &#x3D;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2014-08-27T20:01:18.000Z">
<meta property="article:modified_time" content="2023-09-03T22:16:27.665Z">
<meta property="article:author" content="Z.H. Fu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fuzihaofzh.github.io/blog/2014/08/27/C++%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++语言精要 | 切问录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">切问录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://fuzihaofzh.github.io/blog/2014/08/27/C++%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/lion.png">
      <meta itemprop="name" content="Z.H. Fu">
      <meta itemprop="description" content="Z.H. Fu的博客，主要关注数学、力学、计算机相关内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="切问录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++语言精要
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2014-08-27 21:01:18" itemprop="dateCreated datePublished" datetime="2014-08-27T21:01:18+01:00">2014-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-03 23:16:27" itemprop="dateModified" datetime="2023-09-03T23:16:27+01:00">2023-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/blog/2014/08/27/C++%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/08/27/C++语言精要/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <center>By Z.H. Fu</center>
<center><a href="https://fuzihaofzh.github.io/blog/">https://fuzihaofzh.github.io/blog/</a></center>
### 几种必考虑的情况
- 只要有除法，就一定要讨论分母为0；
- 一定要判断函数输入参数是否合法；
- 指针使用时判断是否非0，用完了置为0。
<h3 id="函数压栈顺序"><a class="markdownIt-Anchor" href="#函数压栈顺序"></a> 函数压栈顺序</h3>
<p>从右往左。<br />
所以</p>
<pre><code>int g = 1;
printf(&quot;%d, %d&quot;, g, ++g);
</code></pre>
<p>结果为2,2</p>
<pre><code>int g = 1;
printf(&quot;%d, %d&quot;, g, g++);
</code></pre>
<p>结果为2,1，说明g++.exe是解析一个参数就加一次，不是解析完一行再加。</p>
<h3 id="条件解析顺序"><a class="markdownIt-Anchor" href="#条件解析顺序"></a> 条件解析顺序</h3>
<p>从左往右，如果当前已经足以判断（&amp;&amp;前面是False或||前面是True），则不会计算后续条件。</p>
<h3 id="boolalpha"><a class="markdownIt-Anchor" href="#boolalpha"></a> boolalpha</h3>
<p>函数名称，功能是把bool值显示为true或false。</p>
<pre><code>cout &lt;&lt; boolalpha &lt;&lt; ( str1==str2 ) &lt;&lt; endl;
</code></pre>
<h3 id="int"><a class="markdownIt-Anchor" href="#int"></a> (int &amp;)</h3>
<p>float a = 1.0f<br />
cout&lt;&lt;(int &amp;)a<br />
从a的起始地址开始，读取sizeof(int)长度，当整数输出</p>
<span id="more"></span>
<h3 id="类型长度"><a class="markdownIt-Anchor" href="#类型长度"></a> 类型长度：</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td>1(sizeof是1，但是有warning)</td>
</tr>
<tr>
<td>空类</td>
<td>1（和void一样）</td>
</tr>
<tr>
<td>bool</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>long double</td>
<td>12(32位系统)，16（64位系统）</td>
</tr>
<tr>
<td>所有指针</td>
<td>4(32位系统)，8（64位系统）</td>
</tr>
</tbody>
</table>
<h3 id="整数的存储方式"><a class="markdownIt-Anchor" href="#整数的存储方式"></a> 整数的存储方式</h3>
<p>是倒着存的，如0xFFEEDDF7在内存中为F7 DD EE FF<br />
所以：</p>
<pre><code>unsigned int a = 0xFFEEDDF7;
unsigned char *b = (unsigned char *)&amp;a;
printf(&quot;%x&quot;,b[0]);
</code></pre>
<p>输出为F7</p>
<h3 id="高精度赋值给低精度"><a class="markdownIt-Anchor" href="#高精度赋值给低精度"></a> 高精度赋值给低精度</h3>
<p>产生截断，类似于用低精度的指针直接指向高精度的首位，再赋值给低精度变量<code>unsigned char b = *((unsigned char *)&amp;a)</code>由于整数是倒着存放的，所以产生的是低位截断。</p>
<pre><code>unsigned int a = 0xFFEEDDF7;
unsigned char b = a;
long long c = 0xAABBCCDD11223344;
int d = c;
printf(&quot;%x，%x&quot;,b,d);
</code></pre>
<p>输出为F7,11223344</p>
<h3 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h3>
<p>逻辑非，按位取反&gt;乘除加减&gt;位移&gt;比较大小&gt;按位与异或或&gt;逻辑运算&gt;赋值运算</p>
<h3 id="消去最低位的1"><a class="markdownIt-Anchor" href="#消去最低位的1"></a> 消去最低位的1</h3>
<p><code>x=x&amp;(x-1)</code><br />
该表达式消去了x二进制数中最低端的1，可用于计算x二进制数中有几个1，或者判断x是否是2的N次方。</p>
<h3 id="位运算的方法求平均数"><a class="markdownIt-Anchor" href="#位运算的方法求平均数"></a> 位运算的方法求平均数</h3>
<pre><code>int x = 729;
int y = 271;
cout&lt;&lt;((x&amp;y) + ((x^y)&gt;&gt;1));
</code></pre>
<p>输出为500，x&amp;y表示x和y中相同的位，也等于x，y中相同位的平均数（因为他们相同），x^y表示x、y中不同的位相加，&gt;&gt;1表示除以2取平均数。综上，这个表达式就是取两个数的平均数。</p>
<h3 id="只用位运算实现加法"><a class="markdownIt-Anchor" href="#只用位运算实现加法"></a> 只用位运算实现加法</h3>
<pre><code>int Add(int a, int b)&#123;
if(0 == b)return a;//没有进位则返回
int sum,carry;
sum = a^b;//不考虑进位的加法
carry = (a&amp;b)&lt;&lt;1;//算出要进位的地方，并左移到该加的位置
return Add(sum,carry);//递归相加
&#125;
</code></pre>
<h3 id="交换两个数"><a class="markdownIt-Anchor" href="#交换两个数"></a> 交换两个数</h3>
<pre><code>a^=b
b^=a
a^=b
</code></pre>
<h3 id="extern-c"><a class="markdownIt-Anchor" href="#extern-c"></a> extern “C”</h3>
<p>C++实现重载函数是将这个函数进行改名，在后面加上参数，如foo（int，int）编译后变成_foo_int_int_，用C去调用这个函数会出问题，因此加上extern &quot;C&quot;之后，则编译后会得到一个符合C规范的名字。</p>
<h2 id="用宏获取结构体中某个元素相对于结构体头的偏移地址"><a class="markdownIt-Anchor" href="#用宏获取结构体中某个元素相对于结构体头的偏移地址"></a> 用宏获取结构体中某个元素相对于结构体头的偏移地址</h2>
<pre><code># define FIND(struc,e) (size_t)&amp;(((struc*)0)-&gt;e)
</code></pre>
<p>先将0强制转化为struc*类型，这样，它的首地址就是0，因此偏移量就等于e的绝对地址，再将其转换为int型的即可。</p>
<h3 id="用宏定义一年有多少秒"><a class="markdownIt-Anchor" href="#用宏定义一年有多少秒"></a> 用宏定义一年有多少秒</h3>
<pre><code># define (60 * 60 * 24 * 365)UL
</code></pre>
<p>注意后面的UL，以及在宏中，任何变量都应该用括号括起来</p>
<h3 id="用宏定义min函数"><a class="markdownIt-Anchor" href="#用宏定义min函数"></a> 用宏定义MIN函数</h3>
<pre><code># define MIN(A,B) ((A)&lt;=(B)?(A):(B))
</code></pre>
<p>注意括号</p>
<h3 id="关于const"><a class="markdownIt-Anchor" href="#关于const"></a> 关于const</h3>
<table>
<thead>
<tr>
<th>申明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>const int * a;</td>
<td>指向的东西不能变</td>
</tr>
<tr>
<td>int const * a;</td>
<td>通上</td>
</tr>
<tr>
<td>int * const a;</td>
<td>指针本身不能变</td>
</tr>
<tr>
<td>int f()const;</td>
<td>该函数不能改变成员变量</td>
</tr>
<tr>
<td>const int * f();</td>
<td>该函数返回一个指针，不能通过指针来改变指向的变量</td>
</tr>
</tbody>
</table>
<p>总结：</p>
<ul>
<li>在<em>左边的const表示指向的东西不能变，在</em>右边的const表示指针不能再指向其他变量。</li>
<li>const成员函数中，若需改变成员变量，则将需要改变的成员变量用mutable关键字修饰。</li>
</ul>
<h3 id="结构体对齐"><a class="markdownIt-Anchor" href="#结构体对齐"></a> 结构体对齐</h3>
<p>结构体为了读取方便，会对数据元素进行对齐，对齐方式就是取这里面最大的数据类型，为每一个数据所占的长度，其他的小的数据不够的话则补齐。<br />
如有一下代码：</p>
<pre><code>struct ST
&#123;
int i;
bool b;
double d;
&#125;;

struct ST2
&#123;
int i;
double d;
bool b;
&#125;;
cout&lt;&lt;sizeof(ST);//=16
cout&lt;&lt;sizeof(ST2);//=24
cout&lt;&lt;endl;
cout&lt;&lt;FIND(ST,i)&lt;&lt;FIND(ST,b)&lt;&lt;FIND(ST,d)&lt;&lt;sizeof(ST);
</code></pre>
<p>输出<br />
16 24<br />
0 4 8 16<br />
这里，double是最长的元素，所以对齐长度取8，其中bool型的被压缩在i没填完的地方里面了。可见，一个结构体中元素出现顺序不一样，结构体的大小不一样。</p>
<p>|i|i|i|i|b| | | |<br />
|—|—|—|—|<br />
|d|d|d|d|d|d|d|d|</p>
<p>用<code># pragma pack(n)</code>可以更改对齐方式，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的话，那么尽量按1对齐，如果大于1，如double、int等，那么就按它本身大小对齐。</p>
<h3 id="堆与栈"><a class="markdownIt-Anchor" href="#堆与栈"></a> 堆与栈</h3>
<p>一个由c/C++编译的程序占用的内存分为以下几个部分 ：</p>
<p>1、栈区（stack）―   由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</p>
<p>2、堆区（heap） ―   一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵；</p>
<p>3、全局区（静态区）（static）―，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放 ；</p>
<p>4、文字常量区  ―常量字符串就是放在这里的。 程序结束后由系统释放 ；</p>
<p>5、程序代码区―存放函数体的二进制代码。<br />
详见：<br />
<a target="_blank" rel="noopener" href="http://zhidao.baidu.com/link?url=ejKPzQ9sYih1Q3sYirWst8L1JmYVGopR6WQrfu2_c5zpAbdgoOvpxfzdTOYusNKUG7k9UqVnCM9jy2BxTXskk_">http://zhidao.baidu.com/link?url=ejKPzQ9sYih1Q3sYirWst8L1JmYVGopR6WQrfu2_c5zpAbdgoOvpxfzdTOYusNKUG7k9UqVnCM9jy2BxTXskk_</a></p>
<h3 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h3>
<p>malloc：值分配内存，返回的只有void指针，失败返回0<br />
calloc：分配内存，并全部置0；参数为两个，一个是大小一个是多少<br />
new：自动执行构造函数，自动计算内存大小，是运算符而不是函数，失败时抛出异常。</p>
<h2 id="关于sizeof的一些补充"><a class="markdownIt-Anchor" href="#关于sizeof的一些补充"></a> 关于sizeof的一些补充</h2>
<pre><code>char * p = &quot;123456&quot;;
char a[] = &quot;123456&quot;;
cout&lt;&lt;sizeof(p);
cout&lt;&lt;sizeof(*p);
cout&lt;&lt;sizeof(a);
cout&lt;&lt;sizeof(*a);
</code></pre>
<p>输出4 1 7 1<br />
1)注意sizeof一个数组名，得到的是数组占用空间大小，这是数组和指针的区别之一！</p>
<p>2)sizeof 是运算符不是函数，因此可以sizeof一个类型，如果是变量的话可以不加括号！<code>sizeof a``sizeof (int)</code></p>
<p>3)sizeof 的返回类型是size_t，是一个与机器有关的无符号整型</p>
<p>4)数组传给sizeof的时候不退化，传给strlen时，退化为指针`,实际上，数组在传给任意函数之后都退化成了指针，在子函数中，不知道数组大小，需要在传一个参数进去。</p>
<p>5）sizeof 类似于一个特殊的宏，在编译时会将所有的变量、表达式替换为其相应的类型，因此，在程序运行过程中，sizeof括号里的标的是得不到执行。<code>sizeof（a=4）;</code>a的值是不会改变的，同理<code>sizeof(f())</code>的f()也得不到执行。</p>
<p>6)sizeof不能用于计算动态数组的大小</p>
<h3 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h3>
<p>作用：用基类指针去调用子类函数，实现多态。<br />
实现方法：虚函数表，在一个有虚函数的类的开头有虚函数指针，里面指向了一个虚函数的列表如图：</p>
<p>对于多重继承就会有多个虚函数表的指针，就像这样：</p>
<p>因此对于一个没有虚函数的类，sizeof(B)=1，对于单继承的有虚函数的类，sizeof(D)=4，而对于多继承则sizeof(D)=4*n<br />
一般来讲，虚函数指针放在对象的第一个位置，因此其的地址就是类的地址。我们可以通过函数指针强行指向类的第一个指针指向的函数地址，来实现调用，这种方法可以直接调用private函数，是C++的一个bug。<br />
详见 <a target="_blank" rel="noopener" href="http://blog.csdn.net/haoel/article/details/1948051/">http://blog.csdn.net/haoel/article/details/1948051/</a></p>
<h3 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h3>
<p>编译器会将代码直接替换到调用的地方，会做检查，而宏则不会。<code>inline</code>应与函数定义放在一起，而不是声明。内联函数常用于一些大型工程。</p>
<h2 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h2>
<h3 id="指针和数组名的区别"><a class="markdownIt-Anchor" href="#指针和数组名的区别"></a> 指针和数组名的区别</h3>
<p>指针占空间，数组名不占空间</p>
<pre><code>char * c=&quot;hello&quot;;//&quot;hello&quot;分配在常量区
char c[]=&quot;hello&quot;;//&quot;hello&quot;分配在栈上这个c不占空间，sizeof(c)
得到的是数组长度。我怀疑是编译之后直接用一个常地址给替换了

const char * strA()
&#123;
    char c[] = &quot;hello&quot;;//&quot;hello&quot;分配在栈上，程序结束即消除，
        //所以这种写法错误
    return c;
&#125;
const char * strA()
&#123;
    static char c[] = &quot;hello&quot;;//&quot;hello&quot;分配在常量和全局区，
        //返回之后不会消失，合法
    return c;
&#125;
</code></pre>
<h3 id="指针减法"><a class="markdownIt-Anchor" href="#指针减法"></a> 指针减法</h3>
<p>会自动除以一个sizeof(当前类型)</p>
<h3 id="用派生类指针指向基类"><a class="markdownIt-Anchor" href="#用派生类指针指向基类"></a> 用派生类指针指向基类</h3>
<p>一般我们用基类指针指向派生类，实现多态，<br />
而用派生类指针指向基类是非法的，如果非要这么做，则需使用dynamic_cast</p>
<pre><code>Derived *d = dynamic_cast&lt;Derived *&gt;( new Base());
</code></pre>
<h3 id="main函数返回值"><a class="markdownIt-Anchor" href="#main函数返回值"></a> main函数返回值</h3>
<p>如果没写，则编译器自动返回0，所有函数都必须有返回值。</p>
<h3 id="一些指针"><a class="markdownIt-Anchor" href="#一些指针"></a> 一些指针</h3>
<table>
<thead>
<tr>
<th>指针类型</th>
<th>写法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数指针</td>
<td>void (*pf)()</td>
<td>声明时一定要加类型void (*pf)(int,int)=&amp;f;</td>
</tr>
<tr>
<td>函数返回指针</td>
<td>void *f()</td>
<td></td>
</tr>
<tr>
<td>const指针</td>
<td>const int * p</td>
<td>指向的东西不能变，指向const int a，因此直接加了个*</td>
</tr>
<tr>
<td>指向const的指针</td>
<td>int * const p</td>
<td>p本身的值不能变，而指向的东西可以变</td>
</tr>
<tr>
<td>指向const的const指针</td>
<td>const int * const p</td>
<td>上面两个合起来</td>
</tr>
</tbody>
</table>
<h3 id="一些指针示例"><a class="markdownIt-Anchor" href="#一些指针示例"></a> 一些指针示例</h3>
<table>
<thead>
<tr>
<th>语句</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float(**def)[10]</code></td>
<td>def是一个二级指针，指向一个指向一维数组的指针，一位数组元素都是float</td>
</tr>
<tr>
<td><code>double*(*gh)[10]</code></td>
<td>gh是一个指针，指向一个一维数组，数组元素都是double *</td>
</tr>
<tr>
<td><code>double(*f[10])()</code></td>
<td>f是一个数组，有10个元素，元素都是函数指针，指向返回double型的无参数的函数</td>
</tr>
<tr>
<td><code>int*((*b)[10])</code></td>
<td>和<code>int*(*b[10])</code>相同，是指向一维数组的指针</td>
</tr>
<tr>
<td><code>long (*fun)(int)</code></td>
<td>函数指针</td>
</tr>
<tr>
<td><code>int(*(*f)(int,int))(int)</code></td>
<td>f是一个函数指针，指向一个以两个int为参数，返回一个函数指针的函数，返回的函数输入一个int输出一个int</td>
</tr>
<tr>
<td><code>int * a[10]</code></td>
<td>一个数组，有10个int* 元素</td>
</tr>
<tr>
<td><code>int (*a)[10]</code></td>
<td>一个指针，指向一个有10个int元素的数组</td>
</tr>
<tr>
<td>以<code>int * (*p)[10]</code>为例说明判断方式，先找到变量，这是一个指针，然后看最左边，表示的是数据类型是指向整型的指针，右边表示是指向数组的指针。综上，是一个指向一位数组的指针，一位数组里都是<code>int *</code>。</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="数组名"><a class="markdownIt-Anchor" href="#数组名"></a> 数组名</h3>
<p>数组名的值是个指针常量，《C和指针》p142中说到，在以下两中场合下，数组名并不是用指针常量来表示，就是当数组名作为sizeof操作符和单目操作符&amp;的操作数时。 sizeof返回整个数组的长度。 &amp;a产生的是一个指向数组的指针，而不是一个指向某个指针常量的指针。所以&amp;a后返回的指针便是指向数组的指针，跟a（一个指向a[0]的指针）在指针的类型上是有区别的。<br />
定义char a[] = “hello”;</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>含义</th>
<th>sizeof</th>
<th>cout</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>常指针，指向a[0]</td>
<td>6</td>
<td>hello</td>
</tr>
<tr>
<td>a+1</td>
<td>常指针，指向a[1]</td>
<td>4</td>
<td>ello</td>
</tr>
<tr>
<td>*a</td>
<td>取a的第0个元素</td>
<td>1</td>
<td>h</td>
</tr>
<tr>
<td>&amp;a</td>
<td>获得一个指向数组的指针变量</td>
<td>4</td>
<td>0x22ff0a</td>
</tr>
<tr>
<td>&amp;a+1</td>
<td>指向首地址加上数组长度的那个元素，已经超出数组范围</td>
<td>-</td>
<td>22ff10</td>
</tr>
<tr>
<td>*&amp;a</td>
<td>获得上面指针所指示的数组</td>
<td>6</td>
<td>hello</td>
</tr>
</tbody>
</table>
<p>代码：</p>
<pre><code>char a[] = &quot;hello&quot;;
 cout &lt;&lt; sizeof(a)&lt;&lt;&quot; &quot;&lt;&lt; sizeof(&amp;a)&lt;&lt;&quot; &quot;&lt;&lt; sizeof(*a)&lt;&lt;&quot; &quot;&lt;&lt; sizeof(*&amp;a)&lt;&lt;&quot; &quot;;
 cout &lt;&lt; (a)&lt;&lt;&quot; &quot;&lt;&lt; (&amp;a)&lt;&lt;&quot; &quot;&lt;&lt; (*a)&lt;&lt;&quot; &quot;&lt;&lt; (*&amp;a)&lt;&lt;&quot; &quot;;
</code></pre>
<p>输出</p>
<pre><code>6 4 1 6 hello 0x22ff0a h hello
</code></pre>
<p>总的来说，a是一个指向数组第0个元素的指针，长度为1，而&amp;为指向数组的指针，长度为n，指示在sizeof(a)的时候变为n，比较特殊。</p>
<h3 id="指针和句柄"><a class="markdownIt-Anchor" href="#指针和句柄"></a> 指针和句柄</h3>
<p>句柄是系统提供的系统资源虚拟地址，类似于指针，但是windows会经常将空闲对象释放，需要用时重新加载，因此用物理地址就没法找到，因此需要引入指针来管理。</p>
<h3 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h3>
<p>1、在可以使用 boost 库的场合下，拒绝使用 std::auto_ptr，因为其不仅不符合 C++ 编程思想，而且极容易出错。不能复制，因此其管理的对象不能放入 std::vector 等容器中。</p>
<p>2、在确定对象无需共享的情况下，使用 boost::scoped_ptr（当然动态数组使用boost::scoped_array）。</p>
<p>3、在对象需要共享的情况下，使用 boost::shared_ptr（当然动态数组使用boost::shared_array）。</p>
<p>4、在需要访问 boost::shared_ptr 对象，而又不想改变其引用计数的情况下，使用boost::weak_ptr，一般常用于软件框架设计中。</p>
<p>5、最后一点，也是要求最苛刻一点：在你的代码中，不要出现 delete 关键字（或 C 语言的free 函数），因为可以用智能指针去管理。</p>
<p>来源： <a target="_blank" rel="noopener" href="http://blog.csdn.net/xt_xiaotian/article/details/5714477">http://blog.csdn.net/xt_xiaotian/article/details/5714477</a></p>
<h3 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h3>
<p>C++的this指针和Python一样，其实是成员函数的一个隐藏参数，而在成员函数中，亦是通过this指针来区别不同的对象。静态成员函数没有this指针。</p>
<h2 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h2>
<h3 id="浅拷贝"><a class="markdownIt-Anchor" href="#浅拷贝"></a> 浅拷贝</h3>
<p>含有指针的对象，如果只进行浅拷贝，即直接复制的话，会引发指针重复析构的问题。因此，含有指针的对象最好不要放到容器中，或者定义拷贝构造函数，使用深拷贝。</p>
<h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2>
<h3 id="面向对象五个基本原则"><a class="markdownIt-Anchor" href="#面向对象五个基本原则"></a> 面向对象五个基本原则</h3>
<ol>
<li>单一职责（Single-Responsibility Principle）：就一个类而言，应该仅有一个引起它变化的原因。防止原因间相互交叉。</li>
<li>开放封闭原则（Open-Closed Principle）：是说软件实体（类、模块、函数等等）应该可以扩展的，但是不可修改。</li>
<li>依赖倒置原则（Dependency-Inversion Principle）：抽象不应该依赖细节，细节应该依赖于抽象。</li>
<li>里氏替换原则（Liskov-Substituent  Principe.）：子类必须能够替换掉它们的父类。其意思：子类必须具有父类的所有特性</li>
<li>接口隔离原则（Interface-Segregation Principle）：多个专用接口优于一个单一的通用接口。其意思：不要将所有的方法都添加到一个接口中。</li>
</ol>
<h3 id="编译器默认生成的四个成员函数"><a class="markdownIt-Anchor" href="#编译器默认生成的四个成员函数"></a> 编译器默认生成的四个成员函数</h3>
<p>构造函数、析构函数、拷贝构造函数、赋值构造函数。</p>
<blockquote>
<p>其中</p>
</blockquote>
<ul>
<li>赋值构造函数就是重载等号；</li>
<li>拷贝构造函数用于生成新对象的时候，此时，即使是用<code>A a1=a</code>，调用的也是拷贝构造函数，不会调用重载等号。</li>
</ul>
<h3 id="生成类对象要不要加括号"><a class="markdownIt-Anchor" href="#生成类对象要不要加括号"></a> 生成类对象要不要加括号</h3>
<p>如果构造函数有参数，显然要加括号，但是，如果构造函数没有参数，则不能加括号，加了就变成函数声明了。<br />
例如：</p>
<pre><code>A a(1);
B b;
B b();//错误，这是声明b是一个返回值为B类型的函数。
</code></pre>
<h3 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员"></a> 静态成员</h3>
<ul>
<li>
<p>静态成员变量：非const型static变量只能在类声明外初始化。</p>
</li>
<li>
<p>静态成员函数：可以直接使用A::f()的形式调用，不用生成对象。</p>
<p>class A<br />
{<br />
public:<br />
const static int a = 1;//const static可以直接初始化<br />
static int b;<br />
static int f();<br />
};<br />
int A::b = 2;//初始化，不能加static<br />
int main()<br />
{<br />
…<br />
}</p>
</li>
</ul>
<h3 id="初始化列表"><a class="markdownIt-Anchor" href="#初始化列表"></a> 初始化列表</h3>
<ul>
<li>
<p>在构造函数的定义中指定；</p>
</li>
<li>
<p>带参数对象（成员对象、基类对象）、引用成员、const只能在初始化列表中初始化；</p>
</li>
<li>
<p>初始化顺序由成员定义的顺序决定，跟初始化列表里的顺序无关（考点）。</p>
<p>class A<br />
{<br />
public:<br />
A(int i):b(i++),a(i++),c(0){}<br />
int a;<br />
int b;<br />
const int c;<br />
};<br />
int main()<br />
{<br />
A t(1);<br />
cout&lt;&lt;t.a&lt;&lt;&quot; “&lt;&lt;t.b&lt;&lt;” “&lt;&lt;t.c&lt;&lt;” &quot;;<br />
}</p>
</li>
</ul>
<p>打印 1 2 0</p>
<h3 id="成员变量初始化位置"><a class="markdownIt-Anchor" href="#成员变量初始化位置"></a> 成员变量初始化位置</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>初始化位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>const</td>
<td>构造函数初始化列表</td>
</tr>
<tr>
<td>static</td>
<td>在类外定义</td>
</tr>
<tr>
<td>const static</td>
<td>在声明时定义</td>
</tr>
</tbody>
</table>
<pre><code>class A
&#123;
public:
	static int a;
	const int b;
	const static int c = 0;
	A():b(0)&#123;&#125;
&#125;;
int A::a = 0;
</code></pre>
<h3 id="构造函数和析构函数"><a class="markdownIt-Anchor" href="#构造函数和析构函数"></a> 构造函数和析构函数</h3>
<table>
<thead>
<tr>
<th></th>
<th>构造函数</th>
<th>析构函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>防止类被实例化，实现单例模式；或者只提供一些工具</td>
<td>只在堆上生成实例，如果在栈上生成实例，函数退出，会有自动析构，编译不通过。需自己添加析构函数Destory()</td>
</tr>
<tr>
<td>virtual</td>
<td>禁止这种写法。因为对象还没构造好，不能动态绑定</td>
<td>要实现多态，需采用虚析构函数，保证用delete基函数指针时，能调用派生类的析构函数</td>
</tr>
</tbody>
</table>
<h3 id="继承和多态"><a class="markdownIt-Anchor" href="#继承和多态"></a> 继承和多态</h3>
<p>继承实现了代码重用<br />
多态实现了接口重用</p>
<h3 id="覆盖override和重载overload"><a class="markdownIt-Anchor" href="#覆盖override和重载overload"></a> 覆盖（override）和重载（overload）</h3>
<p>覆盖通过虚函数的方式<br />
重载通过不同参数的方式</p>
<h3 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h3>
<ul>
<li>构造函数中抛出异常时，程序会按构造顺序，逆序析构已经构造的变量；</li>
<li>析构函数最好不要抛出异常，因为会导致资源无法释放；</li>
<li>最好不要直接使用指针，因为在构造函数构造抛出异常时，无法自动释放指针，最好用智能指针。</li>
</ul>
<h3 id="虚函数-2"><a class="markdownIt-Anchor" href="#虚函数-2"></a> 虚函数</h3>
<p>虚函数使用的成员变量视传入他自己的this指针而定。也就是说，是哪一个类的虚函数，就调用哪一个类的变量。</p>
<h3 id="继承规则"><a class="markdownIt-Anchor" href="#继承规则"></a> 继承规则</h3>
<p>下表表示不同的基类成员类型在不同继承方式下，在子类里面的访问类型。注意基类的private和变成子类private的区别，基类是private，外界和子类都不能访问，变成子类private类型，子类可以访问，外界不能访问。</p>
<table>
<thead>
<tr>
<th>继承方式\成员类型</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>public</td>
<td>protected</td>
<td>不能访问</td>
</tr>
<tr>
<td>protected</td>
<td>protected</td>
<td>protected</td>
<td>不能访问</td>
</tr>
<tr>
<td>private</td>
<td>private</td>
<td>private</td>
<td>不能访问</td>
</tr>
</tbody>
</table>
<h3 id="多重继承"><a class="markdownIt-Anchor" href="#多重继承"></a> 多重继承</h3>
<p>多重继承能节省空间，避免冲突。</p>
<pre><code>A       A             A
 \     /             / \
  B   C       →     B   C
   \ /               \ /
    D                 D
</code></pre>
<p>声明方式：</p>
<pre><code>class A;
class B:public virtual A;
class C:public virtual A;
class D:public B,public C;
</code></pre>
<p>如果B，C中有同名变量，则需在D中用B::a，C::a区别。<br />
虚继承中，每个父类都保留了自己的虚函数表，普通继承中总共只有一个虚函数表。</p>
<h3 id="纯虚函数"><a class="markdownIt-Anchor" href="#纯虚函数"></a> 纯虚函数</h3>
<p>纯虚函数定义为<code>virtual int f()=0</code>，含有纯虚函数的类不能实例化对象。子类如果没有将基类的纯虚函数重写完，那么它仍然含有纯虚函数，仍然不能被实例化。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2014/07/21/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E4%B8%AD%E7%9A%84s%E6%98%AF%E4%BB%80%E4%B9%88/" rel="prev" title="拉普拉斯变换中的s是什么">
      <i class="fa fa-chevron-left"></i> 拉普拉斯变换中的s是什么
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2014/08/30/%E4%BB%8E%E5%8A%9B%E5%81%9A%E5%8A%9F%E5%88%B0%E8%B4%A8%E8%83%BD%E6%96%B9%E7%A8%8B/" rel="next" title="从力做功到质能方程">
      从力做功到质能方程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text"> 函数压栈顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text"> 条件解析顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#boolalpha"><span class="nav-number">3.</span> <span class="nav-text"> boolalpha</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int"><span class="nav-number">4.</span> <span class="nav-text"> (int &amp;)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6"><span class="nav-number">5.</span> <span class="nav-text"> 类型长度：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text"> 整数的存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%B5%8B%E5%80%BC%E7%BB%99%E4%BD%8E%E7%B2%BE%E5%BA%A6"><span class="nav-number">7.</span> <span class="nav-text"> 高精度赋值给低精度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">8.</span> <span class="nav-text"> 运算符优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E5%8E%BB%E6%9C%80%E4%BD%8E%E4%BD%8D%E7%9A%841"><span class="nav-number">9.</span> <span class="nav-text"> 消去最低位的1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%B1%82%E5%B9%B3%E5%9D%87%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text"> 位运算的方法求平均数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95"><span class="nav-number">11.</span> <span class="nav-text"> 只用位运算实现加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0"><span class="nav-number">12.</span> <span class="nav-text"> 交换两个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern-c"><span class="nav-number">13.</span> <span class="nav-text"> extern “C”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%AE%8F%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%B4%E7%9A%84%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80"><span class="nav-number"></span> <span class="nav-text"> 用宏获取结构体中某个元素相对于结构体头的偏移地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%80%E5%B9%B4%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%92"><span class="nav-number">1.</span> <span class="nav-text"> 用宏定义一年有多少秒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89min%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text"> 用宏定义MIN函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Econst"><span class="nav-number">3.</span> <span class="nav-text"> 关于const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90"><span class="nav-number">4.</span> <span class="nav-text"> 结构体对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88"><span class="nav-number">5.</span> <span class="nav-text"> 堆与栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">6.</span> <span class="nav-text"> 内存分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Esizeof%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85"><span class="nav-number"></span> <span class="nav-text"> 关于sizeof的一些补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text"> 虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text"> 内联函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number"></span> <span class="nav-text"> 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text"> 指针和数组名的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%87%8F%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text"> 指针减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%9F%BA%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text"> 用派生类指针指向基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.</span> <span class="nav-text"> main函数返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%8C%87%E9%92%88"><span class="nav-number">5.</span> <span class="nav-text"> 一些指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%8C%87%E9%92%88%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.</span> <span class="nav-text"> 一些指针示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D"><span class="nav-number">7.</span> <span class="nav-text"> 数组名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%8F%A5%E6%9F%84"><span class="nav-number">8.</span> <span class="nav-text"> 指针和句柄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">9.</span> <span class="nav-text"> 智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">10.</span> <span class="nav-text"> this指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stl"><span class="nav-number"></span> <span class="nav-text"> STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.</span> <span class="nav-text"> 浅拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text"> 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%94%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">1.</span> <span class="nav-text"> 面向对象五个基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text"> 编译器默认生成的四个成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%A6%81%E4%B8%8D%E8%A6%81%E5%8A%A0%E6%8B%AC%E5%8F%B7"><span class="nav-number">3.</span> <span class="nav-text"> 生成类对象要不要加括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">4.</span> <span class="nav-text"> 静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text"> 初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BD%8D%E7%BD%AE"><span class="nav-number">6.</span> <span class="nav-text"> 成员变量初始化位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text"> 构造函数和析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">8.</span> <span class="nav-text"> 继承和多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96override%E5%92%8C%E9%87%8D%E8%BD%BDoverload"><span class="nav-number">9.</span> <span class="nav-text"> 覆盖（override）和重载（overload）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">10.</span> <span class="nav-text"> 异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-2"><span class="nav-number">11.</span> <span class="nav-text"> 虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99"><span class="nav-number">12.</span> <span class="nav-text"> 继承规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">13.</span> <span class="nav-text"> 多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text"> 纯虚函数</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Z.H. Fu"
      src="/blog/images/lion.png">
  <p class="site-author-name" itemprop="name">Z.H. Fu</p>
  <div class="site-description" itemprop="description">Z.H. Fu的博客，主要关注数学、力学、计算机相关内容</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Z.H. Fu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">137k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">8:19</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://maplewizard.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://fuzihaofzh.github.io/blog/2014/08/27/C++%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81/";
    this.page.identifier = "2014/08/27/C++语言精要/";
    this.page.title = "C++语言精要";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://maplewizard.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
